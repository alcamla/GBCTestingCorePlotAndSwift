//
//  EEGRealTimeStaticPlot.swift
//  GBCTestingCorePlotAndSwift
//
//  Created by camacholaverde on 5/22/15.
//  Copyright (c) 2015 gibicgroup. All rights reserved.
//


class EEGRealTimeStaticPlot: realTimeStaticPlot {
    
    
    /// The EEG model
    var model:EEGModel!
    
    /// An small stack to keep track of the lastest samples being generated by the model
    var stack:[Int: Float] = [0 : 0.0]{
        didSet{
            //Check if the number of elements in the dictionary does exceeds the required elements
            var keys:[Int] = Array(stack.keys)
            keys = keys.sorted(){$0<$1}
            let keysToDelete = keys.filter(){$0 < (self.localIndex - self.model.order - self.graphContainer!.samplesPerFrame)}
            for key in keysToDelete{
                stack[key] = nil
            }
        }
    }
    
    
    convenience init(identifier:String, eegChannel:EEGModelChannels, eegCondition: EEGModelConditions) {
        // Load the model of the desired signal
        self.init(identifier:identifier)
        let modelAsDictionary = EEGModelsManager.loadEEGModelForCondition(eegCondition, channel: eegChannel)
        model = EEGModel(modelDictionary: modelAsDictionary!)
    }
    
    convenience init(identifier:String, eegChannel:EEGModelChannels, eegCondition: EEGModelConditions, lineStyle:CPTLineStyle){
        self.init(identifier:identifier, eegChannel:eegChannel, eegCondition:eegCondition)
        for count in 0..<subPlotsContainers.count{
            var subPlotContainer = subPlotsContainers[count]
            subPlotContainer.plot.dataLineStyle = lineStyle
        }
    }
    
    /**
    
    Adds new Data to plot. The new value to add  is calculated from the models
    
    */
    func addDataToPlot2(){
        
        // Identify the roles of each subplotContainer
        let inactiveSubPlotIndex = activeSubPlotContainerIndex == 0 ? 1 : 0
        let inactiveSubPlot = subPlotsContainers[inactiveSubPlotIndex]
        let subPlotContainer = subPlotsContainers[activeSubPlotContainerIndex]
        
        if let dataPointsAmount = graphContainer?.samplesPerFrame{
            
            // Remove the given number of dataPoints
            inactiveSubPlot.removeDataPointsFromPlot(dataPointsAmount)
            
            // Insert the given number of dataPoints in the active subplot
            var array:[Double] = [Double]()
            var newValue:Float!
            var simulationIndex = graphContainer!.simulationIndex
            
            for index in simulationIndex*dataPointsAmount ..< simulationIndex*dataPointsAmount + dataPointsAmount {
                localIndex = index
                var sampleValue:Float = 0
                // Get the current simulation index
                
                for  i in 0..<model.order{
                    if index > i{
                        sampleValue = sampleValue - (model.coefficients[i] * stack[index - i - 1]!)
                    }
                    
                }
                newValue = sampleValue + EEGModel.whiteNoise()
                stack[index] = newValue
                //lastValue = newValue
                array.append(Double(newValue))
            }
            subPlotContainer.addDataPointsToPlot(array)
        }
    }

}
